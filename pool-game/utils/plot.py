r""" 
USAGE:
python .\utils\plot.py --log-dir "path/to/log
"""

import os
import time
import argparse
import numpy as np
import pandas as pd
from matplotlib import pyplot as plt
from typing import Callable, List, Optional, Tuple
from stable_baselines3.common.monitor import load_results

X_TIMESTEPS = "timesteps"
X_EPISODES = "episodes"
X_WALLTIME = "walltime_hrs"
POSSIBLE_X_AXES = [X_TIMESTEPS, X_EPISODES, X_WALLTIME]
EPISODES_WINDOW = 100


def moving_average(values, window):
    """
    Smooth values by doing a moving average
    :param values: (numpy array)
    :param window: (int)
    :return: (numpy array)
    """
    weights = np.repeat(1.0, window) / window
    return np.convolve(values, weights, "valid")


def simple_plot_results(log_folder, title="Learning Curve"):
    """
    plot the results

    :param log_folder: (str) the save location of the results to plot
    :param title: (str) the title of the task to plot
    """
    x, y = ts2xy(load_results(log_folder), "timesteps")
    print(y[0])
    y = moving_average(y, window=50)
    # Truncate x
    x = x[len(x) - len(y) :]

    fig = plt.figure(title)
    plt.plot(x, y)
    plt.xlabel("Number of Timesteps")
    plt.ylabel("Rewards")
    plt.title(title + " Smoothed")
    plt.show()


def rolling_window(array: np.ndarray, window: int) -> np.ndarray:
    """
    Apply a rolling window to a np.ndarray
    :param array: the input Array
    :param window: length of the rolling window
    :return: rolling window on the input array
    """
    shape = array.shape[:-1] + (array.shape[-1] - window + 1, window)
    strides = array.strides + (array.strides[-1],)
    return np.lib.stride_tricks.as_strided(array, shape=shape, strides=strides)


def window_func(
    var_1: np.ndarray, var_2: np.ndarray, window: int, func: Callable
) -> Tuple[np.ndarray, np.ndarray]:
    """
    Apply a function to the rolling window of 2 arrays
    :param var_1: variable 1
    :param var_2: variable 2
    :param window: length of the rolling window
    :param func: function to apply on the rolling window on variable 2 (such as np.mean)
    :return:  the rolling output with applied function
    """
    var_2_window = rolling_window(var_2, window)
    function_on_var2 = func(var_2_window, axis=-1)
    return var_1[window - 1 :], function_on_var2


def ts2xy(data_frame: pd.DataFrame, x_axis: str) -> Tuple[np.ndarray, np.ndarray]:
    """
    Decompose a data frame variable to x ans ys
    :param data_frame: the input data
    :param x_axis: the axis for the x and y output
        (can be X_TIMESTEPS='timesteps', X_EPISODES='episodes' or X_WALLTIME='walltime_hrs')
    :return: the x and y output
    """
    if x_axis == X_TIMESTEPS:
        x_var = np.cumsum(data_frame.l.values)
        y_var = data_frame.r.values
    elif x_axis == X_EPISODES:
        x_var = np.arange(len(data_frame))
        y_var = data_frame.r.values
    elif x_axis == X_WALLTIME:
        # Convert to hours
        x_var = data_frame.t.values / 3600.0
        y_var = data_frame.r.values
    else:
        raise NotImplementedError
    return x_var, y_var


def plot_curves(
    xy_list: List[Tuple[np.ndarray, np.ndarray]],
    x_axis: str,
    title: str,
    use_line: bool,
    figsize: Tuple[int, int] = (8, 6),
) -> None:
    """
    plot the curves
    :param xy_list: the x and y coordinates to plot
    :param x_axis: the axis for the x and y output
        (can be X_TIMESTEPS='timesteps', X_EPISODES='episodes' or X_WALLTIME='walltime_hrs')
    :param title: the title of the plot
    :param figsize: Size of the figure (width, height)
    """

    plt.figure(title, figsize=figsize)
    max_x = max(xy[0][-1] for xy in xy_list)
    min_x = 0
    for (_, (x, y)) in enumerate(xy_list):
        if use_line:
            plt.plot(x, y, color="#8fc5e3", linewidth=10)
        else:
            plt.scatter(x, y, s=3, color="#8fc5e3")

        # Do not plot the smoothed curve at all if the timeseries is shorter than window size.

        # Compute and plot rolling mean with window of size EPISODE_WINDOW
        x, y_mean = window_func(x, y, EPISODES_WINDOW, np.mean)
        plt.plot(x, y_mean, color="#3882ab", linewidth=2.0)
    plt.xlim(min_x, max_x)
    plt.title(title)
    plt.xlabel(x_axis)
    plt.ylabel("Episode Rewards")
    plt.tight_layout()


def plot_results(
    dirs: List[str],
    num_timesteps: Optional[int],
    x_axis: str,
    task_name: str,
    use_line: bool,
    recursive: bool,
    figsize: Tuple[int, int] = (8, 6),
) -> None:
    """
    Plot the results using csv files from ``Monitor`` wrapper.
    :param dirs: the save location of the results to plot
    :param num_timesteps: only plot the points below this value
    :param x_axis: the axis for the x and y output
        (can be X_TIMESTEPS='timesteps', X_EPISODES='episodes' or X_WALLTIME='walltime_hrs')
    :param task_name: the title of the task to plot
    :param figsize: Size of the figure (width, height)
    """

    data_frames = []
    for folder in dirs:
        data_frame = load_results(folder)
        if num_timesteps is not None:
            data_frame = data_frame[data_frame.l.cumsum() <= num_timesteps]
        data_frames.append(data_frame)
    xy_list = [ts2xy(data_frame, x_axis) for data_frame in data_frames]
    plot_curves(xy_list, x_axis, title=task_name, use_line=use_line, figsize=figsize)
    if recursive:
        try:
            plt.pause(10)
        except KeyboardInterrupt:
            plt.close()
            os._exit(0)
    else:
        plt.show()


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("--log-dir", type=str, default="logs/sac")
    parser.add_argument(
        "-s", "--simple", help="increase output verbosity", action="store_true"
    )
    parser.add_argument("-l", "--use-line", action="store_true")
    parser.add_argument("-r", "--recursive", action="store_true")
    args = parser.parse_args()
    if args.recursive:
        while 1:
            if args.simple:
                simple_plot_results(args.log_dir)
            else:
                plot_results(
                    [args.log_dir],
                    np.inf,
                    X_TIMESTEPS,
                    "Model Performance",
                    args.use_line,
                    args.recursive,
                )
    else:
        if args.simple:
            simple_plot_results(args.log_dir)
        else:
            plot_results(
                [args.log_dir],
                np.inf,
                X_TIMESTEPS,
                "Model Performance",
                args.use_line,
                args.recursive,
            )
